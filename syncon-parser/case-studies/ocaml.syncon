// This file is transliterated fairly literally from http://caml.inria.fr/pub/docs/manual-ocaml/language.html
// Any additions or changes made can be found at the end of the file, most of the initial stuff is made as direct a translation as possible
// Delimitation: ignoring polymorphic variants, objects, and #-types

type Ident
syncon lowerIdent: Ident = id:LowerIdent
syncon upperIdent: Ident = id:UpperIdent
token UpperIdent = "[[:upper:]][[:alnum:]_']*"   // was called "capitalized-ident"
token LowerIdent = "[[:lower:]_][[:alnum:]_']*"  // was called "lowercase-ident"

token Integer = "([0-9][0-9_]*|(0x|0X)[0-9a-fA-F][0-9a-fA-F_]*|(0o|0O)[0-7][0-7_]*|(0b|0B)[0-1][0-1_]*)"  // was called "integer-literal"

// TODO: this does not include hexadecimal notation for floats
// NOTE: the original made both decimal point and e notation optional, but that makes it overlap with
//       Integer, so I've here changed it to require at least one of them (messy regex)
token Float = "-?([0-9][0-9_]*((\\.[0-9_]*)([eE][+\\-]?[0-9][0-9_])?|(\\.[0-9_]*)?([eE][+\\-]?[0-9][0-9_])))" // was called "float-literal"

token Character = "'([^'\\\\]|\\\\[\\\\nrtb\"[:space:]]|\\\\[0-9][0-9][0-9]|\\\\x[0-9a-fA-F][0-9a-fA-F]|\\\\o[0-7][0-7][0-7])'"
// TODO: strings also have \u{} and \<newline>
token String = "\"([^\"\\\\]|\\\\[\\\\nrtb\"[:space:]]|\\\\[0-9][0-9][0-9]|\\\\x[0-9a-fA-F][0-9a-fA-F]|\\\\o[0-7][0-7][0-7])*\""

// TODO: these are defined as tokens as opposed to a sequence of other terminals to avoid ambiguity, see if we can get away with the "proper" way to do it
token Label = "~[[:lower:]_][[:alnum:]_']*"
token OptLabel = "\\?[[:lower:]_][[:alnum:]_']*"

token HashSymbol = "#[!$%&*+\\-./:<=>?@^|~]+"
token StarStarSymbol = "\\*\\*[!$%&*+\-./:<=>?@^|~]*"
token StarSymbol = "\\*([!$%&+\-./:<=>?@^|~][!$%&+\-./:<=>?@^|~]*)?"
token DivSymbol = "/[!$%&*+\-./:<=>?@^|~]*"
token PercentSymbol = "%[!$%&*+\-./:<=>?@^|~]*"
token PlusSymbol = "\\+[!$%&*+\-./:<=>?@^|~]*"
token MinusSymbol = "-[!$%&*+\-./:<=>?@^|~]*"
token AtSymbol = "@[!$%&*+\-./:<=>?@^|~]*"
token CaretSymbol = "\\^[!$%&*+\-./:<=>?@^|~]*"
token EqualSymbol = "=[!$%&*+\-./:<=>?@^|~]*"
token LessThanSymbol = "<[!$%&*+\-./:<=>?@^|~]*"
token GreaterThanSymbol = ">[!$%&*+\-./:<=>?@^|~]*"
token BarSymbol = "|[!$%&*+\-./:<=>?@^|~]*"
token AndSymbol = "&[!$%&*+\-./:<=>?@^|~]*"
token DollarSymbol = "$[!$%&*+\-./:<=>?@^|~]*"

// === 7.3 Names ===

// The first elements here should eventually be binding interacting types, i.e., thin wrapper types around (one or more) token types, but for now they're just syntax types with a single syncon per

type ValueName
syncon valueName: ValueName = n:LowerIdent
// TODO: insert parenthesized operator names here (maybe)

type LabelName
syncon labelName: LabelName = n:LowerIdent

type ConstrName
syncon constrName: ConstrName = n:UpperIdent

type TagName
syncon tagName: TagName = n:UpperIdent

type TypeConstrName
syncon typeConstrName: TypeConstrName = n:LowerIdent

type FieldName
syncon fieldName: FieldName = n:LowerIdent

type ModuleName
syncon moduleName: ModuleName = n:UpperIdent

type ModTypeName
syncon modTypeName: ModTypeName = n:LowerIdent
syncon upperModTypeName: ModTypeName = n:UpperIdent

type ClassName
syncon className: ClassName = n:LowerIdent

type InstVarName
syncon instVarName: InstVarName = n:LowerIdent

type MethodName
syncon methodName: MethodName = n:LowerIdent

// The second set of elements here are things that can be referred to with a path, i.e., qualified.
// Again, there should be some form of support for something like this, but for the moment that is
// not the case. Technically OCaml also supports Functor application in these paths, in some cases,
// but we're ignoring that here.

type ValuePath
syncon valuePath: ValuePath = (mn:ModulePath ".")? n:ValueName

type Constr
syncon constr: Constr = (mn:ModulePath ".")? n:ConstrName

type TypeConstr
syncon typeConstr: TypeConstr = (mn:ModulePath ".")? n:TypeConstrName

type Field
syncon field: Field = (mn:ModulePath ".")? n:FieldName

type ModTypePath
syncon modTypePath: ModTypePath = (mn:ModulePath ".")? n:ModTypeName

type ClassPath
syncon classPath: ClassPath = (mn:ModulePath ".")? n:ClassName

type ClassTypePath
syncon classTypePath: ClassTypePath = (mp:ModulePath ".")? n:ClassName

type ModulePath
syncon modulePath: ModulePath = (mn:ModuleName ".")* m:ModuleName

type ExtendedModulePath
syncon extendedModulePath: ExtendedModulePath = mp:ModulePath  // TODO: implement extended modulepaths

// === 7.4 Type Expressions ===

type TypExpr

syncon tyVar: TypExpr = "'" id:Ident
syncon anonType: TypExpr = "_"
infix right funType: TypExpr = "->"
prefix labeledFunType: TypExpr = opt:"?"? l:LabelName ":" a:TypExpr "->"
syncon prodType: TypExpr = a:rec ("*" b:rec)+
syncon simpleTypeConstr: TypExpr = n:TypeConstr
postfix unaryTypeConstr: TypExpr = n:TypeConstr
syncon manyTypeConstr: TypExpr = "(" head:TypExpr ("," tail:TypExpr)+ ")" n:TypeConstr
postfix asTyVar: TypExpr = "as" "'" id:Ident

precedence {
  unaryTypeConstr;
  prodType;
  funType labeledFunType;
  asTyVar;
}

// === 7.5 Constants ===

// These are just put into Exp and Pat directly. Empty list, array, and begin end are joined with their
// non-empty versions.
// BUG in manual grammar: begin end is not a valid pattern, which the manual suggests

syncon intLit: Exp = i:Integer
syncon floatLit: Exp = f:Float
syncon charLit: Exp = c:Character
syncon stringLit: Exp = s:String
syncon constrLit: Exp = c:Constr
syncon trueLit: Exp = "true"
syncon falseLit: Exp = "false"
syncon unitLit: Exp = "()"

syncon intPat: Pat = i:Integer
syncon floatPat: Pat = f:Float
syncon charPat: Pat = c:Character
syncon stringPat: Pat = s:String
syncon constrPat: Pat = c:Constr
syncon truePat: Pat = "true"
syncon falsePat: Pat = "false"
syncon unitPat: Pat = "()"

// === 7.6 Patterns ===

type Pat

syncon bindPat: Pat = n:ValueName
syncon wildPat: Pat = "_"
postfix asPat: Pat = "as" n:ValueName
syncon typedPat: Pat = "(" p:Pat ":" ty:TypExpr ")"
infix left orPat: Pat = "|"
prefix constrAppPat: Pat = c:Constr
syncon tupPat: Pat = a:rec ("," b:rec)+
syncon listPat: Pat = "[" (head:Pat (";" tail:Pat) ";"?)? "]"
infix right consPat: Pat = "::"
syncon arrayPat: Pat = "[|" (head:Pat (";" tail:Pat) ";"?)? "|]"
syncon charRangePat: Pat = a:Character ".." b:Character
prefix lazyPat: Pat = "lazy"  // Technically from chapter 8.3, but eh

precedence {
  lazyPat;
  constrAppPat;
  consPat;
  tupPat;
  orPat;
  asPat;
}

// === 7.7 Expressions ===

type Exp
grouping "(" Exp ")"

syncon identExp: Exp = id:ValuePath
syncon beginEnd: Exp = "begin" e:Exp "end"
syncon typeAnnotation: Exp = "(" e:Exp ":" t:TypExpr ")"
syncon tuple: Exp = a:rec ("," b:rec)+
prefix constrExp: Exp = c:Constr
infix right consExp: Exp = "::"
syncon list: Exp = "[" (head:Exp (";" tail:Exp)* ";"?)? "]"
syncon array: Exp = "[|" (head:Exp (";" tail:Exp)* ";"?)? "|]"
postfix application: Exp =
  ( e1:rec
  | "~" l1:LabelName (":" e2:rec)?
  | "?" l2:LabelName (":" e3:rec)?
  )+
prefix neg: Exp = "-"
prefix negFloat: Exp = "-."
infix left product: Exp = "*"
infix left sum: Exp = "+"
infix left difference: Exp = "-"
infix left differenceFloat: Exp = "-."
infix left equal: Exp = "="
infix left notEqual: Exp = "!="
infix left lessThan: Exp = "<"
infix left greaterThan: Exp = ">"
infix right orText: Exp = "or"
infix right or: Exp = "||"
infix right andSingle: Exp = "&"
infix right andDouble: Exp = "&&"
infix right refAssign: Exp = ":="
infix left mod: Exp = "mod"
infix left land: Exp = "land"
infix left lor: Exp = "lor"
infix left lxor: Exp = "lxor"
infix right lsl: Exp = "lsl"
infix right lsr: Exp = "lsr"
infix right asr: Exp = "asr"
postfix fieldAccess: Exp = "." f:Field
infix right fieldUpdate: Exp = "." f:Field "<-"
postfix arrayAccess: Exp = "." "(" e:Exp ")"
infix right arrayUpdate: Exp = "." "(" e:Exp ")" "<-"
postfix stringAccess: Exp = "." "[" e:Exp "]"
infix right stringUpdate: Exp = "." "[" e:Exp "]" "<-"
syncon if: Exp = "if" c:Exp "then" t:Exp ("else" e:Exp)?
syncon while: Exp = "while" c:Exp "do" b:Exp "done"
syncon for: Exp = "for" v:ValueName "=" e1:Exp "to" e2:Exp "do" b:Exp "done"
syncon forDownto: Exp = "for" v:ValueName "=" e1:Exp "downto" e2:Exp "do" b:Exp "done"
infix right seqComp: Exp = ";"
syncon match: Exp =
  "match" e:Exp "with"
  "|"? p1:Pat ("when" c1:Exp)? "->" r1:Exp
  ("|" p:Pat ("when" c:Exp)? "->" r:Exp)*

syncon function: Exp =
  "function"
  "|"? p1:Pat ("when" c1:Exp)? "->" r1:Exp
  ("|" p:Pat ("when" c:Exp)? "->" r:Exp)*

prefix fun: Exp = "fun" p:Parameter+ (":" ty:TypExpr)? "->"
syncon try:
  Exp = "try" e:Exp "with"
  "|"? p1:Pat ("when" c1:Exp)? "->" r1:Exp
  ("|" p:Pat ("when" c:Exp)? "->" r:Exp)*

prefix let: Exp =
  "let" recursive:"rec"? l:LetBinding
  ("and" l2:LetBinding)*
  "in"

prefix assert: Exp = "assert"
prefix lazy: Exp = "lazy"
prefix letModule: Exp =
  "let" "module" m:ModuleName
  ("(" an:ModuleName ":" amt:ModuleType ")")*
  (":" mt:ModuleType)
  "=" me:ModuleExp "in"

prefix letOpen: Exp = "let" "open" mp:ModulePath "in"
syncon anonOpen: Exp = mp:ModulePath "." "(" e:Exp ")"
syncon anonOpenList: Exp = mp:ModulePath "." "[" (head:Exp (";" tail:Exp)* ";"?)? "]"  // NOTE: the informal grammar suggests that this is only valid if it's a length 1 list, but the text and compiler clarifies that it works fine for multiple elements
syncon anonOpenArray: Exp = mp:ModulePath "." "[|" (head:Exp (";" tail:Exp)* ";"?)? "|]"

infix customHashOp: Exp = o:HashSymbol
infix right customStarStarOp: Exp = o:StarStarSymbol
infix left customStarOp: Exp = o:StarSymbol
infix left customDivOp: Exp = o:DivSymbol
infix left customPercentOp: Exp = o:PercentSymbol
infix left customPlusOp: Exp = o:PlusSymbol
infix left customMinusOp: Exp = o:MinusSymbol
infix right customAtOp: Exp = o:AtSymbol
infix right customCaretOp: Exp = o:CaretSymbol
infix left customEqualOp: Exp = o:EqualSymbol
infix left customLessThanOp: Exp = o:LessThanSymbol
infix left customGreaterThanOp: Exp = o:GreaterThanSymbol
infix left customBarOp: Exp = o:BarSymbol
infix left customAndOp: Exp = o:AndSymbol
infix left customDollarOp: Exp = o:DollarSymbol

precedence {
  fieldAccess arrayAccess stringAccess;
  application constrExp assert lazy;
  neg negFloat;
  lsl lsr asr;
  mod land lor lxor;
  sum difference differenceFloat;
  consExp;
  equal notEqual lessThan greaterThan;
  andSingle andDouble;
  orText or;
  tuple;
  fieldUpdate arrayUpdate stringUpdate refAssign;
  !if;
  seqComp;
  let letModule letOpen fun !match !function !try;
}
// TODO: write out forbids for "if", "match", "function", and "try"

type LetBinding
syncon patBinding: LetBinding = p:Pat "=" e:Exp
syncon funcBinding: LetBinding = v:ValueName p:Parameter+ (":" ty:TypExpr)? "=" e:Exp
syncon polyBinding: LetBinding = v:ValueName ":" (("'" i:Ident)+ ".")? ty:TypExpr

type Parameter
syncon patParam: Parameter = p:Pat
syncon simpLabelParam: Parameter = "~" l:LabelName
syncon tyLabelParam: Parameter = "~" "(" l:LabelName (":" ty:TypExpr)? ")"
syncon labelPatParam: Parameter = "~" l:LabelName ":" p:Pat
syncon simpOptParam: Parameter = "?" l:LabelName
syncon tyOptParam: Parameter = "?" "(" l:LabelName (":" ty:TypExpr)? ("=" def:Exp)? ")"
syncon optPatParam: Parameter = "?" l:LabelName ":" p:Pat
syncon optPatTyParam: Parameter = "?" l:LabelName ":" "(" p:Pat (":" ty:TypExpr)? ("=" def:Exp)? ")"

// === 7.8 Type and exception definitions ===

syncon typeDef: SpecAndDef =
  "type" n:"nonrec"?
  tdhead:TypeDef
  ("and" tdtail:TypeDef)*

type TypeDef
syncon typeDefSingle: TypeDef =
  ( (vp:"+"|vm:"-")? "'" ty:Ident
  | "(" (vhp:"+"|vhm:"-")? tyh:Ident ("," (vtp:"+"|vtm:"-")? "'" tyt:Ident)* ")"
  )
  tyn:TypeConstrName
  ("=" eq:TypExpr)?
  "=" tyrepr:TypeRepr
  constraints:("constraint" "'" cvar:Ident "=" cexp:TypExpr)*

type TypeRepr
syncon adtRepr: TypeRepr =
  "|"? ch:ConstrDecl ("|" ct:ConstrDecl)*
syncon recordRepr: TypeRepr =
  "{" fh:FieldDecl (";" ft:FieldDecl)* ";"? "}"
syncon emptyRepr: TypeRepr = "|"

type ConstrDecl
syncon constrDecl: ConstrDecl =
  (n:ConstrName | "[" "]" | "(" "::" ")")
  ("of" head:TypExpr ("*" tail:TypExpr)*)?

type FieldDecl
syncon fieldDecl: FieldDecl =
  mut:"mutable"? n:FieldName ":"
  (("'" var:Ident)+ ".")? e:TypExpr

syncon exceptionDef: SpecAndDef =
  "exception" cd:ConstrDecl
syncon exceptionAlias: Spec =
  "exception" n:ConstrName "=" c:Constr

// === 7.10 Module Types (module specifications) ===

type ModuleType
grouping "(" ModuleType ")"

syncon modTypePathTy: ModuleType = p:ModTypePath
syncon modSig: ModuleType = "sig" (s:Spec ";;"?)* "end"
prefix functorType: ModuleType = "functor" "(" mn:ModuleName ":" mt:ModuleType ")" "->"
infix unnamedFunctorType: ModuleType = "->"
postfix modConstraint: ModuleType = "with" head:ModuleConstraint ("and" tail:ModuleConstraint)*

type ModuleConstraint
syncon modTypeConstraint: ModuleConstraint =
  "type"
  ( (vp:"+"|vm:"-")? "'" ty:Ident
  | "(" (vhp:"+"|vhm:"-")? tyh:Ident ("," (vtp:"+"|vtm:"-")? "'" tyt:Ident)* ")"
  )?
  tyc:TypeConstr
  "=" tye:TypExpr
  constraints:("constraint" "'" cvar:Ident "=" cexp:TypExpr)*
syncon modModConstraint: ModuleConstraint =
  "module" mp:ModulePath "=" emp:ExtendedModulePath

type Spec
type SpecAndDef
syncon sharedSpec: Spec = s:SpecAndDef
syncon val: Spec = "val" vn:ValueName ":" ty:TypExpr
syncon modDecl: Spec =
  "module" mn:ModuleName
  ("(" argn:ModuleName ":" argty:ModuleType ")")*
  ":" mty:ModuleType
syncon modTypeDecl: Spec = "module" "type" mn:ModuleName
syncon includeModType: Spec = "include" mty:ModuleType

syncon external: SpecAndDef =
  "external" vn:ValueName ":" ty:TypExpr "=" e1:String (e2:String e3:String?)?
syncon openMod: SpecAndDef = "open" mp:ModulePath
syncon modTypeAlias: SpecAndDef =
  "module" "type" mn:ModTypeName "=" mty:ModuleType

// === 7.11 Module expressions (module implementations) ===

type ModuleExp
grouping "(" ModuleExp ")"

syncon modExprPath: ModuleExp = mp:ModulePath
syncon struct: ModuleExp =
  "struct"
  (";;"* (dh:Def | eh:Exp) (";;"* (dt:Def | ";;" et:Exp))* ";;"*)?
  "end"
prefix functor: ModuleExp =
  "functor" "(" argn:ModuleName ":" argty:ModuleType ")" "->"
postfix functorApp: ModuleExp =
  "(" arg:ModuleExp ")"
syncon modTypeAssert: ModuleExp =
  "(" me:ModuleExp ":" mty:ModuleType ")"

type Def
syncon sharedDef: Def = s:SpecAndDef
syncon defLet: Def =
  "let" recursive:"rec"?  l:LetBinding
  ("and" l2:LetBinding)*
syncon modDef: Def =
  "module" mn:ModuleName
  ("(" pn:ModuleName ":" pty:ModuleType ")")*
  (":" mty:ModuleType)?
  "=" me:ModuleExp
syncon includeModExp: Def = "include" me:ModuleExp

// === 7.12 Compilation units ===

syncon unitImplementation: Top =
  ";;"* (dh:Def | eh:Exp) (";;"* (dt:Def | ";;" et:Exp))* ";;"*  // NOTE: technically there should be a ? around the entire thing

// syncon unitInterface: Top = (s:Spec ";;"?)*

// === Appendix: added stuff for syncons ===

forbid application.left = application
forbid application.e1 = application
forbid application.e2 = application
forbid application.e3 = application

// Tokens: I disallowed a preceeding minus in integers, instead relying on unary negation
