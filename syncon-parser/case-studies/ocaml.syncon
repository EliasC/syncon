// This file is transliterated fairly literally from http://caml.inria.fr/pub/docs/manual-ocaml/language.html
// Any additions or changes made can be found at the end of the file, most of the initial stuff is made as direct a translation as possible
// Delimitation: ignoring polymorphic variants, objects, and #-types

comment "\\(\\*" "\\*\\)"

comment "#\\d+ *(\"([^\"\\\\]|\\\\[\\\\nrtb'\"[:space:]]|\\\\[0-9][0-9][0-9]|\\\\x[0-9a-fA-F][0-9a-fA-F]|\\\\o[0-7][0-7][0-7])*\")?"

type Ident
syncon lowerIdent: Ident = id:LowerIdent
syncon upperIdent: Ident = id:UpperIdent
token UpperIdent = "[[:upper:]][[:alnum:]_']*"   // was called "capitalized-ident"
token LowerIdent = "[[:lower:]_][[:alnum:]_']*"  // was called "lowercase-ident"

token Integer = "(((0x|0X)[0-9a-fA-F][0-9a-fA-F_]*)|((0o|0O)[0-7][0-7_]*)|((0b|0B)[0-1][0-1_]*)|([0-9][0-9_]*))[lLn]?"  // was called "integer-literal"

// TODO: this does not include hexadecimal notation for floats
// NOTE: the original made both decimal point and e notation optional, but that makes it overlap with
//       Integer, so I've here changed it to require at least one of them (messy regex)
token Float = "-?(0[xX][0-9a-fA-F][0-9a-fA-F_]*\\.[0-9a-fA-F_]*([pP][-+]?\\d[0-9_]*)?)|[0-9][0-9_]*((\\.[0-9_]*)([eE][+\\-]?[0-9][0-9_])?|(\\.[0-9_]*)?([eE][+\\-]?[0-9][0-9_]))" // was called "float-literal"

token Character = "'([^'\\\\]|\\\\[\\\\nrtb'\"[:space:]]|\\\\[0-9][0-9][0-9]|\\\\x[0-9a-fA-F][0-9a-fA-F]|\\\\o[0-7][0-7][0-7])'"
// TODO: strings also have \u{} and \<newline>
token String = "\"([^\"\\\\]|\\\\[\\\\nrtb'\"[:space:]]|\\\\[0-9][0-9][0-9]|\\\\x[0-9a-fA-F][0-9a-fA-F]|\\\\o[0-7][0-7][0-7])*\""
token QuotString = "({\\|([^|]|\\|[^}])*\\|})"

// TODO: these are defined as tokens as opposed to a sequence of other terminals to avoid ambiguity, see if we can get away with the "proper" way to do it
token Label = "~[[:lower:]_][[:alnum:]_']*"
token OptLabel = "\\?[[:lower:]_][[:alnum:]_']*"

token PrefixSymbol = "![!$%&*+\\-./:<=>?@^|~]*|[?!][!$%&*+\\-./:<=>?@^|~]+"
token HashSymbol = "#[!$%&*+\\-./:<=>?@^|~]+"
token StarStarSymbol = "\\*\\*[!$%&*+\-./:<=>?@^|~]*"
token StarSymbol = "\\*([!$%&+\-./:<=>?@^|~][!$%&+\-./:<=>?@^|~]*)?"
token DivSymbol = "/[!$%&*+\-./:<=>?@^|~]*"
token PercentSymbol = "%[!$%&*+\-./:<=>?@^|~]*"
token PlusSymbol = "\\+[!$%&*+\-./:<=>?@^|~]*"
token MinusSymbol = "-[!$%&*+\-./:<=>?@^|~]*"
token AtSymbol = "@[!$%&*+\-./:<=>?@^|~]*"
token CaretSymbol = "\\^[!$%&*+\-./:<=>?@^|~]*"
token EqualSymbol = "=[!$%&*+\-./:<=>?@^|~]*"
token LessThanSymbol = "<[!$%&*+\-./:<=>?@^|~]*"
token GreaterThanSymbol = ">[!$%&*+\-./:<=>?@^|~]*"
token BarSymbol = "\\|[!$%&*+\-./:<=>?@^|~]*"
token AndSymbol = "&[!$%&*+\-./:<=>?@^|~]*"
token DollarSymbol = "$[!$%&*+\-./:<=>?@^|~]*"

// === 7.3 Names ===

// The first elements here should eventually be binding interacting types, i.e., thin wrapper types around (one or more) token types, but for now they're just syntax types with a single syncon per

type ValueName
syncon valueName: ValueName = n:LowerIdent
syncon operatorName: ValueName = "(" on:OperatorName ")"

type OperatorName
syncon preOpName: OperatorName = n:PrefixSymbol
syncon hashOpName: OperatorName = n:HashSymbol
syncon starStarOpName: OperatorName = n:StarStarSymbol
syncon starOpName: OperatorName = n:StarSymbol
syncon divOpName: OperatorName = n:DivSymbol
syncon percentOpName: OperatorName = n:PercentSymbol
syncon plusOpName: OperatorName = n:PlusSymbol
syncon minusOpName: OperatorName = n:MinusSymbol
syncon atOpName: OperatorName = n:AtSymbol
syncon caretOpName: OperatorName = n:CaretSymbol
syncon equalOpName: OperatorName = n:EqualSymbol
syncon lessThanOpName: OperatorName = n:LessThanSymbol
syncon greaterThanOpName: OperatorName = n:GreaterThanSymbol
syncon barOpName: OperatorName = n:BarSymbol
syncon andOpName: OperatorName = n:AndSymbol
syncon dollarOpName: OperatorName = n:DollarSymbol
syncon reservedOpName: OperatorName =
 (star:"*" | plus:"+" | minus:"-" | floatMinus:"-." | eq:"=" | neq:"!=" |
  lt:"<" | gt:">" | or:"or" | barOr:"||" | and:"&" | doubleAnd:"&&" |
  assign:":=" | mod:"mod" | land:"land" | lor:"lor" | lxor:"lxor" |
  lsl:"lsl" | lsr:"lsr" | asr:"asr")
// TODO: insert parenthesized operator names here (maybe)

type LabelName
syncon labelName: LabelName = n:LowerIdent

type ConstrName
syncon constrName: ConstrName = n:UpperIdent

type TagName
syncon tagName: TagName = n:UpperIdent

type TypeConstrName
syncon typeConstrName: TypeConstrName = n:LowerIdent

type FieldName
syncon fieldName: FieldName = n:LowerIdent

type ModuleName
syncon moduleName: ModuleName = n:UpperIdent

type ModTypeName
syncon modTypeName: ModTypeName = n:LowerIdent
syncon upperModTypeName: ModTypeName = n:UpperIdent

type ClassName
syncon className: ClassName = n:LowerIdent

type InstVarName
syncon instVarName: InstVarName = n:LowerIdent

type MethodName
syncon methodName: MethodName = n:LowerIdent

// The second set of elements here are things that can be referred to with a path, i.e., qualified.
// Again, there should be some form of support for something like this, but for the moment that is
// not the case. Technically OCaml also supports Functor application in these paths, in some cases,
// but we're ignoring that here.

type ValuePath
syncon valuePath: ValuePath = (mn:ModulePath ".")? n:ValueName

type Constr
syncon constr: Constr = (mn:ModulePath ".")? n:ConstrName

type TypeConstr
syncon typeConstr: TypeConstr = (mn:ExtendedModulePath ".")? n:TypeConstrName

type Field
syncon field: Field = (mn:ModulePath ".")? n:FieldName

type ModTypePath
syncon modTypePath: ModTypePath = (mn:ExtendedModulePath ".")? n:ModTypeName

type ClassPath
syncon classPath: ClassPath = (mn:ModulePath ".")? n:ClassName

type ClassTypePath
syncon classTypePath: ClassTypePath = (mp:ExtendedModulePath ".")? n:ClassName

type ModulePath
syncon modulePath: ModulePath = (mn:ModuleName ".")* m:ModuleName

type ExtendedModulePath
syncon extendedModulePath: ExtendedModulePath =
  mh:ModuleName ("(" mhp:ExtendedModulePath ")")?
  ("." mt:ModuleName ("(" mtp:ExtendedModulePath ")")?)*

// === 7.4 Type Expressions ===

type TypExpr
grouping "(" TypExpr ")"

syncon tyVar: TypExpr = "'" id:Ident
syncon anonType: TypExpr = "_"
infix right funType: TypExpr = "->"
prefix labeledFunType: TypExpr = opt:"?"? l:LabelName ":" a:TypExpr "->"
syncon prodType: TypExpr = a:rec ("*" b:rec)+
syncon simpleTypeConstr: TypExpr = n:TypeConstr
postfix unaryTypeConstr: TypExpr = n:TypeConstr
syncon manyTypeConstr: TypExpr = "(" head:TypExpr ("," tail:TypExpr)+ ")" n:TypeConstr
postfix asTyVar: TypExpr = "as" "'" id:Ident
syncon knownPolyTag: TypExpr =
  "[" ( ty1:TypExpr? "|" ts1:TagSpec
      | "`" tn1:TagName ("of" tyo1:TypExpr)?)
   ("|" ts2:TagSpec)* "]"
syncon openPolyTag: TypExpr =
  "[>" ts1:TagSpec? ("|" ts2:TagSpec)* "]"
syncon closedPolyTag: TypExpr =
  "[<" "|"? ts1:TagSpecFull ("|" ts2:TagSpecFull)* (">" ("`" tn:TagName)+)? "]"

type TagSpec
syncon explicitTagSpec: TagSpec = "`" tn1:TagName ("of" tyo1:TypExpr)?
syncon exprTagSpec: TagSpec = ty:TypExpr

type TagSpecFull
syncon explicitTagSpecFull: TagSpecFull =
  "`" tn1:TagName ("of" "&"? tyo1:TypExpr ("&" tyo2:TypExpr))?
syncon exprTagSpecFull: TagSpecFull = ty:TypExpr

precedence {
  unaryTypeConstr;
  prodType;
  funType labeledFunType;
  asTyVar;
}

// === 7.5 Constants ===

// These are just put into Exp and Pat directly. Empty list, array, and begin end are joined with their
// non-empty versions.
// BUG in manual grammar: begin end is not a valid pattern, which the manual suggests

syncon intLit: Exp = i:Integer
syncon floatLit: Exp = f:Float
syncon charLit: Exp = c:Character
syncon stringLit: Exp = s:String
syncon quotStringLit: Exp = s:QuotString
syncon constrLit: Exp = c:Constr
syncon trueLit: Exp = "true"
syncon falseLit: Exp = "false"
syncon unitLit: Exp = "()"

syncon intPat: Pat = i:Integer
syncon floatPat: Pat = f:Float
syncon charPat: Pat = c:Character
syncon stringPat: Pat = s:String
syncon constrPat: Pat = c:Constr
syncon truePat: Pat = "true"
syncon falsePat: Pat = "false"
syncon unitPat: Pat = "()"

// === 7.6 Patterns ===

type Pat
grouping "(" Pat ")"

syncon bindPat: Pat = n:ValueName
syncon wildPat: Pat = "_"
postfix asPat: Pat = "as" n:ValueName
syncon typedPat: Pat = "(" p:Pat ":" ty:TypExpr ")"
infix left orPat: Pat = "|"
prefix constrAppPat: Pat = c:Constr
prefix tagAppPat: Pat = "`" t:TagName
syncon tagShortPat: Pat = "#" ty:TypeConstr
syncon tupPat: Pat = a:rec ("," b:rec)+
syncon listPat: Pat = "[" (head:Pat (";" tail:Pat) ";"?)? "]"
infix right consPat: Pat = "::"
syncon arrayPat: Pat = "[|" (head:Pat (";" tail:Pat) ";"?)? "|]"
syncon charRangePat: Pat = a:Character ".." b:Character
prefix lazyPat: Pat = "lazy"  // Technically from chapter 8.3, but eh

syncon recordPat: Pat =
  "{" f:Field (":" ty:TypExpr)? ("=" p:Pat)?
  (";" ft:Field (":" tyt:TypExpr)? ("=" pt:Pat)?)*
  (";" w:"_")? ";"? "}"

precedence {
  lazyPat;
  constrAppPat tagAppPat;
  consPat;
  tupPat;
  orPat;
  asPat;
}

// === 7.7 Expressions ===

type Exp
grouping "(" Exp ")"

syncon identExp: Exp = id:ValuePath
syncon beginEnd: Exp = "begin" e:Exp "end"
syncon typeAnnotation: Exp = "(" e:Exp ":" t:TypExpr ")"
syncon tuple: Exp = a:rec ("," b:rec)+
prefix constrExp: Exp = c:Constr
prefix tagExp: Exp = "`" t:TagName
infix right consExp: Exp = "::"
syncon list: Exp = "[" (head:Exp (";" tail:Exp)* ";"?)? "]"
syncon array: Exp = "[|" (head:Exp (";" tail:Exp)* ";"?)? "|]"
syncon record: Exp =
  "{" f:Field (":" ty:TypExpr)? ("=" val:Exp)?
  (";" ft:Field (":" tyt:TypExpr)? ("=" valt:Exp)?)*
  ";"? "}"
postfix application: Exp =
  ( e1:rec
  | l1:Label (":" e2:rec)?
  | l2:OptLabel (":" e3:rec)?
  )+
prefix neg: Exp = "-"
prefix negFloat: Exp = "-."
infix left product: Exp = "*"
infix left sum: Exp = "+"
infix left difference: Exp = "-"
infix left differenceFloat: Exp = "-."
infix left equal: Exp = "="
infix left notEqual: Exp = "!="
infix left lessThan: Exp = "<"
infix left greaterThan: Exp = ">"
infix right orText: Exp = "or"
infix right or: Exp = "||"
infix right andSingle: Exp = "&"
infix right andDouble: Exp = "&&"
infix right refAssign: Exp = ":="
infix left mod: Exp = "mod"
infix left land: Exp = "land"
infix left lor: Exp = "lor"
infix left lxor: Exp = "lxor"
infix right lsl: Exp = "lsl"
infix right lsr: Exp = "lsr"
infix right asr: Exp = "asr"
postfix fieldAccess: Exp = "." f:Field
infix right fieldUpdate: Exp = "." f:Field "<-"
postfix arrayAccess: Exp = "." "(" e:Exp ")"
infix right arrayUpdate: Exp = "." "(" e:Exp ")" "<-"
postfix stringAccess: Exp = "." "[" e:Exp "]"
infix right stringUpdate: Exp = "." "[" e:Exp "]" "<-"
prefix if: Exp = "if" c:Exp "then" (t:Exp "else")?
syncon while: Exp = "while" c:Exp "do" b:Exp "done"
syncon for: Exp = "for" v:ValueName "=" e1:Exp "to" e2:Exp "do" b:Exp "done"
syncon forDownto: Exp = "for" v:ValueName "=" e1:Exp "downto" e2:Exp "do" b:Exp "done"
infix right seqComp: Exp = ";"
prefix match: Exp =
  "match" e:Exp "with"
  "|"? p1:Pat ("when" c1:Exp)? "->"
  ((refutation:"."|r:Exp) "|" p:Pat ("when" c:Exp)? "->")*
syncon matchRefutation: Exp =
  "match" e:Exp "with"
  ( p1:Pat ("when" c1:Exp)? "->" refutation1:"."
  | ("|" p2:Pat ("when" c2:Exp)? "->" (refutation2:"."|r2:Exp))*
    "|" p3:Pat ("when" c3:Exp)? "->" refutation3:".")

prefix function: Exp =
  "function"
  "|"? p1:Pat ("when" c1:Exp)? "->"
  (r:Exp "|" p:Pat ("when" c:Exp)? "->")*

prefix fun: Exp = "fun" p:Parameter+ (":" ty:TypExpr)? "->"
prefix try: Exp =
  "try" e:Exp "with"
  "|"? p1:Pat ("when" c1:Exp)? "->"
  (r:Exp "|" p:Pat ("when" c:Exp)? "->")*

prefix let: Exp =
  "let" recursive:"rec"? l:LetBinding
  ("and" l2:LetBinding)*
  "in"

prefix assert: Exp = "assert"
prefix lazy: Exp = "lazy"
prefix letModule: Exp =
  "let" "module" m:ModuleName
  ("(" an:ModuleName ":" amt:ModuleType ")")*
  (":" mt:ModuleType)?
  "=" me:ModuleExp "in"

postfix methodInvocation: Exp = "#" mn:MethodName
syncon coercion: Exp = "(" e:Exp (":" fromty:TypExpr)? ":>" ty:TypExpr ")"

prefix letOpen: Exp = "let" "open" mp:ModulePath "in"
syncon anonOpen: Exp = mp:ModulePath "." "(" e:Exp ")"
syncon anonOpenList: Exp = mp:ModulePath "." "[" (head:Exp (";" tail:Exp)* ";"?)? "]"  // NOTE: the informal grammar suggests that this is only valid if it's a length 1 list, but the text and compiler clarifies that it works fine for multiple elements
syncon anonOpenArray: Exp = mp:ModulePath "." "[|" (head:Exp (";" tail:Exp)* ";"?)? "|]"

prefix customPrefixOp: Exp = p:PrefixSymbol
infix customHashOp: Exp = o:HashSymbol
infix right customStarStarOp: Exp = o:StarStarSymbol
infix left customStarOp: Exp = o:StarSymbol
infix left customDivOp: Exp = o:DivSymbol
infix left customPercentOp: Exp = o:PercentSymbol
infix left customPlusOp: Exp = o:PlusSymbol
infix left customMinusOp: Exp = o:MinusSymbol
infix right customAtOp: Exp = o:AtSymbol
infix right customCaretOp: Exp = o:CaretSymbol
infix left customEqualOp: Exp = o:EqualSymbol
infix left customLessThanOp: Exp = o:LessThanSymbol
infix left customGreaterThanOp: Exp = o:GreaterThanSymbol
infix left customBarOp: Exp = o:BarSymbol
infix left customAndOp: Exp = o:AndSymbol
infix left customDollarOp: Exp = o:DollarSymbol

precedence {
  customPrefixOp;
  fieldAccess arrayAccess stringAccess;
  customHashOp methodInvocation;
  application constrExp tagExp assert lazy;
  neg negFloat prefixPlus;
  customStarStarOp lsl lsr asr;
  customStarOp customDivOp customPercentOp product mod land lor lxor;
  customPlusOp customMinusOp sum difference differenceFloat;
  consExp;
  customAtOp customCaretOp;
  customEqualOp customLessThanOp customGreaterThanOp customGreaterThanOp customBarOp customAndOp customDollarOp equal notEqual lessThan greaterThan;
  andSingle andDouble;
  orText or;
  tuple;
  fieldUpdate arrayUpdate stringUpdate refAssign;
  if;
  seqComp;
  let letModule letOpen fun match !matchRefutation function try;
  trailSemi;
}
// TODO: write out forbids for "match", "function", and "try"

type LetBinding
syncon patBinding: LetBinding = p:Pat "=" e:Exp
syncon funcBinding: LetBinding = v:ValueName p:Parameter+ (":" ty:TypExpr)? "=" e:Exp
syncon polyBinding: LetBinding = v:ValueName ":" (("'" i:Ident)+ ".")? ty:TypExpr "=" e:Exp

type Parameter
syncon patParam: Parameter = p:Pat
syncon simpLabelParam: Parameter = "~" l:LabelName
syncon tyLabelParam: Parameter = "~" "(" l:LabelName (":" ty:TypExpr)? ")"
syncon labelPatParam: Parameter = "~" l:LabelName ":" p:Pat
syncon simpOptParam: Parameter = "?" l:LabelName
syncon tyOptParam: Parameter = "?" "(" l:LabelName (":" ty:TypExpr)? ("=" def:Exp)? ")"
syncon optPatParam: Parameter = "?" l:LabelName ":" p:Pat
syncon optPatTyParam: Parameter = "?" l:LabelName ":" "(" p:Pat (":" ty:TypExpr)? ("=" def:Exp)? ")"

// === 7.8 Type and exception definitions ===

syncon typeDef: SpecAndDef =
  "type" n:"nonrec"?
  tdhead:TypeDef
  ("and" tdtail:TypeDef)*

type TypeDef
syncon typeDefSingle: TypeDef =
  ( (vp:"+"|vm:"-")? ("'" ty:Ident | tyw:"_")
  | "(" (vhp:"+"|vhm:"-")? ("'" tyh:Ident | tywh:"_") ("," (vtp:"+"|vtm:"-")? ("'" tyt:Ident | tywt:"_"))* ")"
  )?
  tyn:TypeConstrName
  ("=" eq:TypeEquation)?
  ("=" tyrepr:TypeRepr)? // type-representation
  constraints:("constraint" "'" cvar:Ident "=" cexp:TypExpr)*

type TypeEquation
syncon tyExprEqn: TypeEquation = ty:TypExpr

type TypeRepr
syncon adtRepr: TypeRepr =
  "|"? ch:ConstrDecl ("|" ct:ConstrDecl)*
syncon recordRepr: TypeRepr =
  "{" fh:FieldDecl (";" ft:FieldDecl)* ";"? "}"
syncon emptyRepr: TypeRepr = "|"

type ConstrDecl
syncon constrDecl: ConstrDecl =
  (n:ConstrName | "[" "]" | "(" "::" ")")
  ("of" ca:ConstrArgs)?

type ConstrArgs
syncon normalConstrArgs: ConstrArgs = head:TypExpr ("*" tail:TypExpr)*

type FieldDecl
syncon fieldDecl: FieldDecl =
  mut:"mutable"? n:FieldName ":"
  (("'" var:Ident)+ ".")? e:TypExpr

syncon exceptionDef: SpecAndDef =
  "exception" cd:ConstrDecl
syncon exceptionAlias: Spec =
  "exception" n:ConstrName "=" c:Constr

// === 7.10 Module Types (module specifications) ===

type ModuleType
grouping "(" ModuleType ")"

syncon modTypePathTy: ModuleType = p:ModTypePath
syncon modSig: ModuleType = "sig" (s:Spec ";;"?)* "end"
prefix functorType: ModuleType = "functor" "(" mn:ModuleName ":" mt:ModuleType ")" "->"
infix unnamedFunctorType: ModuleType = "->"
postfix modConstraint: ModuleType = "with" head:ModuleConstraint ("and" tail:ModuleConstraint)*

type ModuleConstraint
syncon modTypeConstraint: ModuleConstraint =
  "type"
  ( (vp:"+"|vm:"-")? "'" ty:Ident
  | "(" (vhp:"+"|vhm:"-")? tyh:Ident ("," (vtp:"+"|vtm:"-")? "'" tyt:Ident)* ")"
  )?
  tyc:TypeConstr
  "=" tye:TypeEquation
  constraints:("constraint" "'" cvar:Ident "=" cexp:TypExpr)*
syncon modModConstraint: ModuleConstraint =
  "module" mp:ModulePath "=" emp:ExtendedModulePath

type Spec
type SpecAndDef
syncon sharedSpec: Spec = s:SpecAndDef
syncon val: Spec = "val" vn:ValueName ":" ty:TypExpr
syncon modDecl: Spec =
  "module" mn:ModuleName
  ("(" argn:ModuleName ":" argty:ModuleType ")")*
  ":" mty:ModuleType
syncon modTypeDecl: Spec = "module" "type" mn:ModuleName
syncon includeModType: Spec = "include" mty:ModuleType

syncon external: SpecAndDef =
  "external" vn:ValueName ":" ty:TypExpr "=" e1:String (e2:String e3:String?)?
syncon openMod: SpecAndDef = "open" mp:ModulePath
syncon modTypeAlias: SpecAndDef =
  "module" "type" mn:ModTypeName "=" mty:ModuleType

// === 7.11 Module expressions (module implementations) ===

type ModuleExp
grouping "(" ModuleExp ")"

syncon modExprPath: ModuleExp = mp:ModulePath
syncon struct: ModuleExp =
  "struct"
  (";;"* (dh:Def | eh:Exp) (";;"* (dt:Def | ";;" et:Exp))* ";;"*)?
  "end"
prefix functor: ModuleExp =
  "functor" "(" argn:ModuleName ":" argty:ModuleType ")" "->"
postfix functorApp: ModuleExp =
  "(" arg:ModuleExp ")"
syncon modTypeAssert: ModuleExp =
  "(" me:ModuleExp ":" mty:ModuleType ")"

type Def
syncon sharedDef: Def = s:SpecAndDef
syncon defLet: Def =
  "let" recursive:"rec"?  l:LetBinding
  ("and" l2:LetBinding)*
syncon modDef: Def =
  "module" mn:ModuleName
  ("(" pn:ModuleName ":" pty:ModuleType ")")*
  (":" mty:ModuleType)?
  "=" me:ModuleExp
syncon includeModExp: Def = "include" me:ModuleExp

// === 7.12 Compilation units ===

syncon unitImplementation: Top =
  ";;"* (dh:Def | eh:Exp) (";;"* (dt:Def | ";;" et:Exp))* ";;"*  // NOTE: technically there should be a ? around the entire thing

// syncon unitInterface: Top = (s:Spec ";;"?)*

// === 8.1.4 Generalized algebraic datatypes ===

syncon gadtConstr: ConstrDecl =
  n:ConstrName ":" (h:TypExpr ("*" t:TypExpr)* "->")? ty:TypExpr

// === 8.5.1 Private variant and record types ===

syncon privateAdtRepr: TypeRepr =
  "private" "|"? ch:ConstrDecl ("|" ct:ConstrDecl)*
syncon privateRecordRepr: TypeRepr =
  "private" "{" fh:FieldDecl (";" ft:FieldDecl)* ";"? "}"

// === 8.5.2 Private type abbreviations ===

syncon privateTypeEqn: TypeEquation = "private" ty:TypExpr

// === 8.8 Locally abstract types ===

syncon tyParam: Parameter = "(" "type" n:TypeConstrName+ ")"
syncon polyLet: LetBinding = vn:ValueName ":" "type" n:TypeConstrName+ "." ty:TypExpr "=" e:Exp

// === 8.16 Attributes ===

type AttrId
syncon lowerAttr: AttrId = n:LowerIdent
syncon upperAttr: AttrId = n:UpperIdent
infix left attrDot: AttrId = "."

type AttrPayload
syncon attrItems: AttrPayload = ";;"* (dh:Def | eh:Exp) (";;"* (dt:Def | ";;" et:Exp))* ";;"*
syncon attrTy: AttrPayload = ":" ty:TypExpr
syncon attrSpec: AttrPayload = ":" spec:Spec?
syncon attrPat: AttrPayload = "?" p:Pat ("when" e:Exp)?

// === 8.17 Extension nodes ===

type Extension
syncon extension: Extension = "[%" id:AttrId payload:AttrPayload "]"

syncon expExt: Exp = e:Extension
syncon tyExt: TypExpr = e:Extension
syncon patExt: Pat = e:Extension
syncon modExt: ModuleExp = e:Extension
syncon modTyExt: ModuleType = e:Extension

type ItemExtension
syncon itemExtension: ItemExtension = "[%%" id:AttrId payload:AttrPayload "]"

syncon defAndSpecExt: SpecAndDef = e:ItemExtension

// ==== 8.19 Exception cases in pattern matching ===

prefix exceptionPat: Pat = "exception"

// === 8.23 Inline records ===

syncon inlineRecord: ConstrArgs = "{" fh:FieldDecl (";" ft:FieldDecl)* ";"? "}"

// === Appendix: added stuff for syncons ===

forbid application.left = application
forbid application.e1 = application
forbid application.e2 = application
forbid application.e3 = application
forbid application.e1 = constrExp
forbid application.e2 = constrExp
forbid application.e3 = constrExp

forbid application.left = constrLit

forbid arrayAccess.left = constrLit
forbid fieldAccess.left = constrLit

forbid list.head = seqComp
forbid list.tail = seqComp
forbid list.head = trailSemi
forbid list.tail = trailSemi
forbid array.head = seqComp
forbid array.tail = seqComp
forbid array.head = trailSemi
forbid array.tail = trailSemi

forbid record.val = seqComp
forbid record.valt = seqComp

forbid tuple.a = tuple
forbid tuple.b = tuple

forbid prodType.a = prodType
forbid prodType.b = prodType

forbid tupPat.a = tupPat
forbid tupPat.b = tupPat

forbid normalConstrArgs.head = prodType
forbid normalConstrArgs.tail = prodType

// Tokens: I disallowed a preceeding minus in integers, instead relying on unary negation

// trailing semicolons in most places where a sequence of expressions is expected. I suspect the implementation isn't really semicolon as an infix operator at all, but rather a (optionally semicolon terminated) semicolon-separated list of expressions in certain locations
postfix trailSemi: Exp = ";" // This is also inserted in the precedence list, at lowest precedence. it is possible that this means that we parse more things than ocaml proper does
forbid trailSemi.left = trailSemi
forbid application.left = trailSemi

forbid match.r = match
forbid match.r = function
forbid match.r = try
forbid function.r = match
forbid function.r = function
forbid function.r = try
forbid try.r = match
forbid try.r = function
forbid try.r = try

prefix prefixPlus: Exp = "+"

// I made if into a prefix operator, which makes the shape of the ast a little bit weird (when if.t has an entry, if.right is the else branch, otherwise it's the then branch)
// similar changes to match, try, and function
// fun is similarly made into a prefix operator, but the thing that we would logically consider the body is always located at fun.right, so it's not as weird
