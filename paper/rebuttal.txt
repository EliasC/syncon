The beginning of this file contains my notes on all the concerns raised by the reviewers. At the end, after "================", is the actual rebuttal.



# Review A (knowledgeable)

line 209: done
line 301: done, but check that the same isn't done elsewher, and that it's clear enough to read without different font or quoting
line 912: slightly simplified, if a language doesn't *need* forbids to be resolvably ambiguous, then we can definitely say resolvably ambiguous. If forbids are needed we cannot answer "resolvably ambiguous" with certainty. The "unresolvably ambiguous" answer is slightly less clear: we can answer this way with certainty if we only need to examine two trees, i.e., if \words(t_1) \subseteq \words(t_2).

Why is operator precedence often mentioned but not really part of any formal constraints, rather assumed as additional meta-level constraints?
- The intent was that forbids would be a strictly more general construct than precedence, whereby the formalities would use forbids, while users would most frequently interact with precedence, which is a more commonly understood thing. The need for deep precedence puts something of a damper on this however.

Why is Theorem 6.1 a theorem, isn't the proof trivial?
- It is indeed, but we figured it'd be better to be overly rigorous where it was easy to do so.

The classical example of if-then-else statement ambiguity is not mentioned in the paper, but it seems to fall into the same category, does it?
- It does indeed. We decided against it since the solution is widely known and accepted, though it does seem a bit dumb to not include right now...



# Review B (no familiarity)
Grammar/spelling issues addressed.
"Overall, nicely written paper and a very novel approach to a rather old problem. My issue is with regards to the practicality of this approach."



# Review C (expert)
- the results/algorithms cover a very limited class of grammars
- it is hard to see whether the general framework proposed in sec 4 is needed
  For this particular language formalism, no, but the general idea could be used for other formalisms with other forms of disambiguation, e.g., semicolons and the like.
- missing a comparison of alternative words and nested words
  TODO: consider this more carefully. You could consider a pair of parens as a nesting level in a nested word.
- the overall approach is not very convincing: It seems that the overall approach shifts the burden of thinking about ambiguity arising from language composition from the language designer to the user, which doesn't make sense to me.
  The idea is that the end-user already runs into these ambiguity issues, it's just that the compiler doesnt' care and picks a semi-arbitrary interpretation. The user's understanding of the grammar is likely ambiguous, though they might not realize it, but the compiler doesn't know this, leading the user to debug ambiguity errors through type errors or runtime errors. E.g. `1 & 3 == 1`, `match` in OCaml, if-then-else ambiguity.

line 70: done
line 94: I assume this means "set both operators at the same relative precedence, and arbitrarily pick left- or right-associativity" (since each operation is likely to be associative, in the mathematical sense, it shouldn't matter which associativity is chosen). The difference is that our approach makes the compiler highlight to the user that there are multiple distinct alternatives, all of which might be what the user intends.
line 144: 2/3 reviewers have now said we should discuss "dangling else", so we probably should. Maybe state that the two problems are essentially the same, but `match` is more likely to become an issue to the user simply by how the languages are used?
line 161: "would it make sense to just speak of derivation trees? The linear notion of derivation doesn't matter at all for this paper." It would indeed.
line 190,192: "why mix \varepsilon and \lambda?" We were following the definition in a particular book, but yes, this should probably just be \epsilon.
line 197: "AFAIK this restricted form is equivalent to the general form. Unless you restrict to deterministic systems, of course." We never use $a = \epsilon$, otherwise true.
line 222: agreed
line 268: added a sentence
line 271: the central required notion is the connection between words and trees, the latter is not present in the classical definition of a language (a set of words).
line 314: true, and done
line 351, 358: done
line 371: this likely means a slight reordering of things, basically a sentence or two, TODO
line 531: "version 3 apparently, nothing can be said about version 3. Version 1 (where soundness and completeness holds) seems a rather draconic and unrealistic restriction. But the authors do not comment on this pragmatic issue." This is essentially just straight up true. We should probably address this. Essentially: the static problem turns out to be harder to solve than one might think, and this is a first attempt at it.
line 551: the alternative word formulation additionally permits multiple nesting edges to share a position, e.g., ((1 + 2)) + 3 corresponds to 1 + 2 + 3 with two nesting levels around 1 + 2, which is not permitted by nesting words.
line 582: intuitively it seems trivial, but actually mechanically proving it is not, I believe (slight weakness here since we haven't actually done it). Quite happy / impressed that this is "obvious". Additional note: it's not just double parens, but also optional parens.
line 932: this could certainly use something at the end that just ties it together. I believe the reasoning has been presented earlier, and this is "just" filling in the blanks, but the conclusion should be present at the end. TODO: look more carefully at this
line 1001: The property is the possibility of constructing this set in finite time, i.e., that it's decidable.
line 1005: True, it should be "[...] the set of trees $t' \in L(T_D)$ such that $\words(t') \cap \bigcup_{i} \words(t_i) \neq \emptyset$ is finite". We should also mention that we use 7.3 to discover the full set of relevant trees, that's its purpose.

sec 8:
It would be good to discuss whether the results achieved in the case study are artifacts of the particular approach to defining the syntax.
- I interpret this to be a request to actually discuss the differences between the formalization version and the syncon version of the specification language, instead of just mentioning it and treating it as a (the) reasonable implementation of it.


--------------------------------

Reviewer A
- can you be more precise when either case can be decided with certainty? (static)

Reviewer C explicit questions:
- what's the relation between alternative words and nested words?
- is there hope for any results for version 3 grammars?

Reviewer C
- very limited class of grammars
- the overall approach is not very convincing: It seems that the overall approach shifts the burden of thinking about ambiguity arising from language composition from the language designer to the user, which doesn't make sense to me.

Reviewer A + C
- if-then-else should be there and/or it's a more well-known version of the match example

===================================================

We thank the reviewers for their thoughtful comments!

#### Overall motivation / Reviewer C on the overall approach
Reviewer C comments that the overall approach shifts the burden of thinking about ambiguity arising from language composition from the language designer to the user. We argue that the user *already* has to deal with ambiguity issues in common general-purpose languages, but without compiler assistance. The programmer's understanding of the syntax of the language is likely ambiguous, possibly without them being aware, e.g., the match example in OCaml or infix operators rarely used together (try predicting the result of evaluating `1 & 3 == 1` in, e.g., C and Python). Resolvable ambiguity allows the compiler to assist in such cases by using an ambiguous grammar.

That said, giving the compiler this capability does not absolve the language designer of the responsibility of making sure their language is convenient to use $-$ it merely provides an alternative way to deal with this sort of edge cases.

#### Reviewers A and C, dangling else
Reviewer A notes the absence of dangling else, and Reviewer C further notes that nested match is essentially the same issue, only the former is more well-known. We decided to use the match example instead since, anecdotally, nested matches in OCaml occur more often than nested if-statements without braces and only a single else, and is thus more likely to become an issue. We will add a comparison to dangling else.

#### Reviewer A, results of the static analysis
Reviewer A asks when the static analysis can give definitive answers. For the static analysis we can achieve a positive result (resolvably ambiguous) for a language that does not need forbids (essentially precedence and associativity) to be resolvable. For example, OCaml does not fit here, since [1; 2] needs to forbid sequential composition as a direct child of a list to be resolvable, while arithmetic expressions do fit, since precedence and associativity are merely conveniences $-$ all possible expressions can be written merely by putting grouping parentheses around all subexpressions.

The negative result is less intuitive, but it arises when some tree can never be disambiguated from some particular other tree, i.e., $\exists t_1, t_2.\ \forall w.\ t_1 \in \mathit{parse}(w) \Rightarrow t_2 \in \mathit{parse}(w)$.

#### Reviewer C, limited class of grammars and hope for version 3
Reviewer C notes that the class of grammars supported by the static analysis is quite limited, which is indeed true (though slightly larger than is immediately obvious, see the previous answer). The contribution here is largely the concept, and the introduction of a problem that is more difficult than it first appears, and some initial steps towards solving it. We thus do not yet know if the problem is decidable for version 3.

The dynamic analysis on the other hand is only limited to languages with balanced parentheses.

#### Reviewer B, practicality
Reviewer B wonders about the practicality of this approach. The OCaml case-study contributes the most to this, in that we can parse 75% of the `.ml` files in the OCaml compiler (including test cases, i.e., many uncommonly used language features). As for efficiency and similar concerns, we leave those for future work.

#### Reviewer C, nested words and our alternative word representation
Reviewer C asks for the relation between nested words and our alternative word representation. They are quite similar, but nested words disallow nesting edges that share a left and/or right point. This makes them unsuitable for our usecase, since that would disallow double parentheses and parentheses of the form `(a(b))`. We will add a comparison to the paper.
